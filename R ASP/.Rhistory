for (j in 1:12) {
for(i in (j+1):20)
m[i,j]=mydata$IN[i-j]
}
INd = m[13:20,1:12] # on supprime les mois où l'on a pas toutes les données à cause du décallage
return(m)
}
INdm = createINd() # création de la matrice
View(INdm)
View(INdm)
View(mydata)
return(INd)
}
createINd = function() {
m = matrix(c(rep(c(rep(0,20)),12)),nrow=20,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):20)
m[i,j]=mydata$IN[i-j]
}
INd = m[13:20,1:12] # on supprime les mois où l'on a pas toutes les données à cause du décallage
return(INd)
}
INdm = createINd() # création de la matrice
View(INdm)
View(INdm)
View(mydata)
View(mydata)
res1= lm(IO1~IN)
IO1=mydata$IO1[2:20]
IN=mydata$IN[1:19]  # on décalle pour pouvoir faire les regressions
res1= lm(IO1~IN)
summary(res1)
INPIB=mydata$IN[1:19]*mydata$PIB[2:20] #même décallage
res2= lm(IO1~INPIB)
summary(INPIB)
summary(res2)
library(rJava,xlsxjars,xlsx)
install.packages(c("boot", "class", "cluster", "codetools", "foreign", "KernSmooth", "lattice", "manipulate", "MASS", "Matrix", "nlme", "nnet", "rpart", "spatial"))
library(rJava,xlsxjars,xlsx)
library(rJava,xlsxjars)
library(xlsx)
mydata = read.xlsx("..//donnees_mensuelles.xlsx",1)  # read from first sheet
install.packages("%")
mydata = read.xlsx(PATH+"/donnees_mensuelles.xlsx",1)  # read from first sheet
mydata = read.xlsx(paste(path,"/donnees_mensuelles.xlsx",sep=""),1)  # read from first sheet
path = sys.getdir()
path = getdir()
library(base)
path = getdir()
path = getwd()
mydata = read.xlsx(paste(path,"/donnees_mensuelles.xlsx",sep=""),1)  # read from first sheet
View(mydata)
# veuillez installer le package xlsx, et activer les packages rJava, xlsxjars et xlsx dans cet ordre pour pouvoir importer les fichiers xlsx
library(rJava,xlsxjars)
library(xlsx)
# importation du fichier xls
path = getwd()
mydata = read.xlsx(paste(path,"/donnees_annuelles.xlsx",sep=""),1)  # read from first sheet
library(rJava,xlsxjars)
library(xlsx)
# importation du fichier xls
path = getwd()
mydata = read.xlsx(paste(path,"/donnees_mensuelles.xlsx",sep=""),1)  # read from first sheet
# regression linéraire de IO1 sur IN
res = lm(IO1 ~ IN,data=mydata)
res
# création d'une matrice dont les collonnes sont le vecteur IN décalé de l'indice de colonne
createINd = function() {
m = matrix(c(rep(c(rep(0,237)),12)),nrow=237,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):237)
m[i,j]=mydata$IN[i-j]
}
INd = m[13:237,1:12] # on supprime les mois où l'on a pas toutes les données à cause du décallage
return(INd)
}
INdm = createINd() # création de la matrice
IO1d =  mydata$IO1[13:237]# décallage du vecteur pour avoir la bonne taille pour la regréssion
# test de la régression multilinéaire de IO sur l'ensemble des IN : modèle de base sans contraintes sur les coefficiants
res1= lm(IO1d~INdm[1:225,1]+INdm[1:225,2]+INdm[1:225,3]+INdm[1:225,4]+INdm[1:225,5]+INdm[1:225,6]
+INdm[1:225,7]+INdm[1:225,8]+INdm[1:225,9]+INdm[1:225,10]+INdm[1:225,11]+INdm[1:225,12])
summary(res1)
res1= lm(IO1d~INdm[1:225,1]+INdm[1:225,2]+INdm[1:225,3]+INdm[1:225,4]+INdm[1:225,5]+INdm[1:225,6]
+INdm[1:225,7]+INdm[1:225,8]+INdm[1:225,9]+INdm[1:225,10]+INdm[1:225,11]+INdm[1:225,12]-1)
summary(res1)
res2= lm(IO1d~INdm[1:225,1]+INdm[1:225,2]+INdm[1:225,3]+INdm[1:225,4]+INdm[1:225,5]+INdm[1:225,6]
+INdm[1:225,7]+INdm[1:225,8]+INdm[1:225,9]+INdm[1:225,10]+INdm[1:225,11]+INdm[1:225,12]-1)
summary(res2)
plot(res2)
summary(res1)
plot(res1)
import(file.R)
setwd("~/GitHub/R-ASP/R ASP")
# Ce fichier se charge d'importer les données utilisées à partir d'un fichier excel
# veuillez installer le package xlsx, et activer les packages rJava, xlsxjars et xlsx dans cet ordre pour pouvoir importer les fichiers xlsx
library(rJava,xlsxjars)
library(xlsx)
# importation du fichier xls
path = getwd()
mydata = read.xlsx("C:\Users\Loïc\Documents\GitHub\R-ASP\R ASP\donnees_mensuelles.xlsx",1)  # read from first sheet
mydata = read.xlsx("C:/Users/Loïc/Documents/GitHub/R-ASP/R ASP/donnees_mensuelles.xlsx",1)  # read from first sheet
View(mydata)
View(mydata)
source("import_files.r")
rm(list=ls())
source("import_files.r")
source("import_files.r")
# CREATION DES OBJETS TIMESERIES
require(graphics)
INts<-ts(mydata$IN, start=c(1995, 1), end=c(2014, 9), frequency=12)
# REPRESENTATION DECOMPOSITION
plot(stl(INts,"per"))
INdecomp<-decompose(INts) # l'objet INdecomp contient alors la decomposition de IN
INdecomp<-decompose(INts, type='multiplicative', filter=NULL)
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
?decompose
View(mydata)
View(mydata)
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
# Le choix de la meilleure désaisonalisation est encore en débat, pour l'heure les deux sont conservées
# Le plot des différentes décomposition ne permet pas de conclure facilement
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
# Création des variables désaisonalisées
INd = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1d = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
View(mydata)
View(mydata)
# Ce fichier se charge de la désaisonalisation des séries
source("import_files.r")
View(mydata)
source("import_files.r")
View(mydata)
# Ce fichier se charge d'importer les données utilisées à partir d'un fichier excel
# veuillez installer le package xlsx, et activer les packages rJava, xlsxjars et xlsx dans cet ordre pour pouvoir importer les fichiers xlsx
library(rJava,xlsxjars)
library(xlsx)
# importation du fichier xls
path = getwd()
mydata = read.xlsx("C:/Users/Loïc/Documents/GitHub/R-ASP/R ASP/donnees_mensuelles.xlsx",1)  # read from first sheet
rm(list=ls())
source("import_files.r")
View(mydata)
View(mydata)
View(mydata)
source("import_files.r")
rm(list=ls())
source("import_files.r")
View(mydata)
IO1 = mydata$IO1[13:237]
IO1dts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
require(graphics)
INts<-ts(mydata$IN, start=c(1995, 1), end=c(2014, 9), frequency=12)
IO1 = mydata$IO1[13:237]
IO1dts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
plot(stl(INts,"per"))
# DECOMPOSITION EFFECTIVE
# Méthode multiplicative et additive
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
# Le choix de la meilleure désaisonalisation est encore en débat, pour l'heure les deux sont conservées
# Le plot des différentes décomposition ne permet pas de conclure facilement
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
# Création des variables désaisonalisées
INd = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1d = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
IO1ts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
# REPRESENTATION DECOMPOSITION
plot(stl(INts,"per"))
# DECOMPOSITION EFFECTIVE
# Méthode multiplicative et additive
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
# Le choix de la meilleure désaisonalisation est encore en débat, pour l'heure les deux sont conservées
# Le plot des différentes décomposition ne permet pas de conclure facilement
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
# Création des variables désaisonalisées
INd = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1d = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
M = matrix(1,12,1)
for (i in 1:12){
M[i,1]=1
}
View(M)
View(M)
M = matrix(1,12,1)
M = matrix(1,12,1)
View(M)
View(M)
l'environement de travail
rm(list=ls())
rm(list=ls())
source("import_files.r")
source("desaisonnalisation.r")
create_mat = function(var) {
m = matrix(c(rep(c(rep(0,237)),12)),nrow=237,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):237)
m[i,j]=var[i-j]
}
m = m[13:237,1:12] # on supprime les mois ou l'on a pas toutes les donnees à cause du decallage
return(m)
}
create_mat = function(var) {
m = matrix(c(rep(c(rep(0,237)),12)),nrow=237,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):237)
m[i,j]=var[i-j]
}
res = m[13:237,1:12] # on supprime les mois ou l'on a pas toutes les donnees à cause du decallage
return(res)
}
IN_mat = create_mat(IN_cjo)
IN_cjo=mydata$IN_cjo
rm(list=ls())
source("desaisonnalisation.r")
Ratio_IPC=mydata$Ratio_IPC # Ratio_IPC = IPC_VO / IPC_VN
IN_cjo=mydata$IN_cjo
create_mat = function(var) {
m = matrix(c(rep(c(rep(0,237)),12)),nrow=237,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):237)
m[i,j]=var[i-j]
}
res = m[13:237,1:12] # on supprime les mois ou l'on a pas toutes les donnees à cause du decallage
return(res)
}
# Creation de la matrice
IN_mat = create_mat(IN_cjo)
View(IN_mat)
View(IN_mat)
res1= lm(IO1~INdm[1:225,1]+INdm[1:225,2]+INdm[1:225,3]+INdm[1:225,4]+INdm[1:225,5]+INdm[1:225,6]
+INdm[1:225,7]+INdm[1:225,8]+INdm[1:225,9]+INdm[1:225,10]+INdm[1:225,11]+INdm[1:225,12])
res1= lm(IO1~IN_mat[1:225,1]+IN_mat[1:225,2]+IN_mat[1:225,3]+IN_mat[1:225,4]+IN_mat[1:225,5]+IN_mat[1:225,6]
+IN_mat[1:225,7]+IN_mat[1:225,8]+IN_mat[1:225,9]+IN_mat[1:225,10]+IN_mat[1:225,11]+IN_mat[1:225,12])
summary(res1)
res2= lm(IO1d~IN_mat[1:225,1]+IN_mat[1:225,2]+IN_mat[1:225,3]+IN_mat[1:225,4]+IN_mat[1:225,5]+IN_mat[1:225,6]
+IN_mat[1:225,7]+IN_mat[1:225,8]+IN_mat[1:225,9]+IN_mat[1:225,10]+IN_mat[1:225,11]+IN_mat[1:225,12]-1)
res2= lm(IO1d~IN_mat[1:225,1]+IN_mat[1:225,2]+IN_mat[1:225,3]+IN_mat[1:225,4]+IN_mat[1:225,5]+IN_mat[1:225,6]
+IN_mat[1:225,7]+IN_mat[1:225,8]+IN_mat[1:225,9]+IN_mat[1:225,10]+IN_mat[1:225,11]+IN_mat[1:225,12]-1)
summary(res2)
rm(list=ls())
source("desaisonnalisation.r")
Ratio_IPC=mydata$Ratio_IPC # Ratio_IPC = IPC_VO / IPC_VN
IN_cjo=mydata$IN_cjo
IO1_cut = mydata$IO1_cjo[36:237]# decallage pour fitter la regression avec Ratio_IPC
create_mat = function(var) {
m = matrix(c(rep(c(rep(0,237)),12)),nrow=237,byrow=TRUE)
for (j in 1:12) {
for(i in (j+1):237)
m[i,j]=var[i-j]
}
res = m[13:237,1:12] # on supprime les mois ou l'on a pas toutes les donnees à cause du decallage
return(res)
}
source("import_files.r")
View(mydata)
View(mydata)
INt_cjo = INt/mydata$X.CJO_5J
INt_cjo = INt/mydata$X.CJO_5J[1:237]
INt_cjo = INt/mydata$X.CJO_5J[1:237]
INs_cjo = INs/mydata$X.CJO_5J[1:237]
IO1t_cjo = IO1t/mydata$X.CJO_5J[1:237]
IO1s_cjo = IO1s/mydata$X.CJO_5J[1:237]
IO1t_cjo = IO1t/mydata$X.CJO_5J[13:237]
IO1s_cjo = IO1s/mydata$X.CJO_5J[13:237]
rm(list=ls())
source("import_files.r")
# CREATION DES OBJETS TIMESERIES
require(graphics)
INts<-ts(mydata$IN, start=c(1995, 1), end=c(2014, 9), frequency=12)
IO1 = mydata$IO1[13:237]
IO1ts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
# REPRESENTATION DECOMPOSITION
plot(stl(INts,"per"))
# DECOMPOSITION EFFECTIVE
# Méthode multiplicative et additive
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
# Le choix de la meilleure désaisonalisation est encore en débat, pour l'heure les deux sont conservées
# Le plot des différentes décomposition ne permet pas de conclure facilement
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
# Création des variables désaisonnalisées
INt = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1t = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
rm(list=ls())
source("import_files.r")
require(graphics)
INts<-ts(mydata$IN, start=c(1995, 1), end=c(2014, 9), frequency=12)
IO1 = mydata$IO1[13:237]
IO1ts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
plot(stl(INts,"per"))
# DECOMPOSITION EFFECTIVE
# Méthode multiplicative et additive
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
# Le choix de la meilleure désaisonalisation est encore en débat, pour l'heure les deux sont conservées
# Le plot des différentes décomposition ne permet pas de conclure facilement
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
INt = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1t = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
INt_cjo = INt/mydata$X.CJO_5J[1:237]
INs_cjo = INs/mydata$X.CJO_5J[1:237]
IO1t_cjo = IO1t/mydata$X.CJO_5J[13:237]
IO1s_cjo = IO1s/mydata$X.CJO_5J[13:237]
view(INT_cjo)
INt = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1t = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
rm(list=ls())
source("import_files.r")
require(graphics)
INts<-ts(mydata$IN, start=c(1995, 1), end=c(2014, 9), frequency=12)
IO1 = mydata$IO1[13:237]
IO1ts<-ts(IO1, start=c(1996, 1), end=c(2014, 9), frequency=12)
plot(stl(INts,"per"))
IN_decomp_add<-decompose(INts, type="additive")
IN_decomp_mult<-decompose(INts, type="multiplicative")
plot(IN_decomp_add)
plot(IN_decomp_mult)
IO1_decomp_add<-decompose(IO1ts, type="additive")
IO1_decomp_mult<-decompose(IO1ts, type="multiplicative")
plot(IO1_decomp_add)
plot(IO1_decomp_mult)
INt = IN_decomp_add$trend
INs = IN_decomp_add$seasonal
IO1t = IO1_decomp_add$trend
IO1s = IO1_decomp_add$seasonal
print(IO1t_cjo)
printts(IO1t_cjo)
INt_cjo = INt/mydata$X.CJO_5J[1:237]
INs_cjo = INs/mydata$X.CJO_5J[1:237]
IO1t_cjo = IO1t/mydata$X.CJO_5J[13:237]
IO1s_cjo = IO1s/mydata$X.CJO_5J[13:237]
print(OI1_cjo)
print(IO1t_cjo)
print(IO1t)
print(IO1s)
rm(list=ls())
source("desaisonnnalisation.r")
source("desaisonnalisation.r")
source("basic_functions.r")
IN_mat = create_mat(INt_cjo)
res1= lm(IO1t_cjo~IN_mat[1:225,1]+IN_mat[1:225,2]+IN_mat[1:225,3]+IN_mat[1:225,4]+IN_mat[1:225,5]+IN_mat[1:225,6]
+IN_mat[1:225,7]+IN_mat[1:225,8]+IN_mat[1:225,9]+IN_mat[1:225,10]+IN_mat[1:225,11]+IN_mat[1:225,12])
summary(res1)
plot(res1)
res2= lm(IO1t_cjo~IN_mat[1:225,1]+IN_mat[1:225,2]+IN_mat[1:225,3]+IN_mat[1:225,4]+IN_mat[1:225,5]+IN_mat[1:225,6]
+IN_mat[1:225,7]+IN_mat[1:225,8]+IN_mat[1:225,9]+IN_mat[1:225,10]+IN_mat[1:225,11]+IN_mat[1:225,12]-1)
summary(res2)
plot(res2)
rm(list=ls())
source("desaisonnalisation.r")
source("basic_functions.R")
Ratio_IPC=mydata$Ratio_IPC # Ratio_IPC = IPC_VO / IPC_VN
IO1t_final = IO1t_cjo[36:237] # decallage pour fitter la regression avec Ratio_IPC
PIB_evol=mydata$PIB_evol
# Creation du vecteur IN_moy, contenant la moyenne mobile des IN.
M = matrix(1,12,1)
IN_moy = IN_mat%*%M
# creation de l a matrice de regression
IN_mat = create_mat(INt_cjo)
View(IN_mat)
View(IN_mat)
View(IN_mat)
res3= lm(IO1t_final~
(1+PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_mat[22:220,1]
+IN_mat[22:220,2]
+IN_mat[22:220,3]
+IN_mat[22:220,4]
+IN_mat[22:220,5]
+IN_mat[22:220,6]
+IN_mat[22:220,7]
+IN_mat[22:220,8]
+IN_mat[22:220,9]
+IN_mat[22:220,10]
+IN_mat[22:220,11]
+IN_mat[22:220,12]-1))
summary(res3)
rm(list=ls())
source("desaisonnalisation.r")
source("basic_functions.R")
Ratio_IPC=mydata$Ratio_IPC # Ratio_IPC = IPC_VO / IPC_VN
IO1t_final = IO1t_cjo[36:237] # decallage pour fitter la regression avec Ratio_IPC
PIB_evol=mydata$PIB_evol
M = matrix(1,12,1)
IN_moy = IN_mat%*%M
IN_mat = create_mat(INt_cjo)
IO1t_final = IO1t_cjo[35:237] # decallage pour fitter la regression avec Ratio_IPC
res3= lm(IO1t_final~
(1+PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_mat[22:220,1]
+IN_mat[22:220,2]
+IN_mat[22:220,3]
+IN_mat[22:220,4]
+IN_mat[22:220,5]
+IN_mat[22:220,6]
+IN_mat[22:220,7]
+IN_mat[22:220,8]
+IN_mat[22:220,9]
+IN_mat[22:220,10]
+IN_mat[22:220,11]
+IN_mat[22:220,12]-1))
res3= lm(IO1t_cjo[35:233]~
(1+PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_mat[22:220,1]
+IN_mat[22:220,2]
+IN_mat[22:220,3]
+IN_mat[22:220,4]
+IN_mat[22:220,5]
+IN_mat[22:220,6]
+IN_mat[22:220,7]
+IN_mat[22:220,8]
+IN_mat[22:220,9]
+IN_mat[22:220,10]
+IN_mat[22:220,11]
+IN_mat[22:220,12]-1))
summary(res3)
# Creation du vecteur IN_moy, contenant la moyenne mobile des IN.
M = matrix(1,12,1)
IN_moy = IN_mat%*%M
View(IN_mat)
View(IN_moy)
res4= lm(IO1d_cut~
(PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_moy[22:220]))
res4= lm(IO1t_cjo[35:233]~
(PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_moy[22:220]))
summary(res4)
res5= lm(IO1d_decomp_trend[36:237]~
(Ratio_IPC[36:237])*(IN_moydecomp_trend[24:225]))
res5= lm(IO1t_cjo[35:233]~
(Ratio_IPC[35:233])*(IN_moy[22:220]))
summary(res5)
res4= lm(IO1t_cjo[35:233]~
(PIB_evol[35:233]+Ratio_IPC[35:233])*(IN_moy[22:220])-1)
summary(res4)
res4= lm(IO1t_cjo[35:233]~
(PIB_evol[35:233]*IN_moy[22:220]+Ratio_IPC[35:233]*IN_moy[22:220]-1)
summary(res4)
res4= lm(IO1t_cjo[35:233]~
((PIB_evol[35:233]+Ratio_IPC[35:233])*IN_moy[22:220]-1)
summary(res4)
res4= lm(IO1t_cjo[35:233]~
((PIB_evol[35:233]+Ratio_IPC[35:233])*)(IN_moy[22:220])-1)
res4= lm(IO1t_cjo[35:233]~
((PIB_evol[35:233]+Ratio_IPC[35:233]))*(IN_moy[22:220])-1)
summary(res4)
coefficients(res4)
res4= lm(IO1t_cjo[35:233]~
((PIB_evol[35:233]+Ratio_IPC[35:233]))*(IN_moy[22:220]-1)-1)
summary(res4)
PIB_evol_IN_moy = PIB_evol[35:233]*IN_moy[22:220]
Ratio_IPC_IN_Moy = Ratio_IPC[35:233]*IN_moy[22:220]
res4= lm(IO1t_cjo[35:233]~
PIB_evol_IN_moy + Ratio_IPC_IN_moy + IN_moy[22:220] - 1)
Ratio_IPC_IN_moy = Ratio_IPC[35:233]*IN_moy[22:220]
res4= lm(IO1t_cjo[35:233]~
PIB_evol_IN_moy + Ratio_IPC_IN_moy + IN_moy[22:220] - 1)
summary(res4)
res5= lm(IO1t_cjo[35:233]~
Ratio_IPC_IN_moy + IN_moy[22:220] - 1)
summary(res5)
conso_VN=mydata$conso_VN
conso_IO1<-c(rep(0,12),mydata$conso_VN[1:225])
print(conso_IO1)
consoVNtemp<-conso_VN[1:237]
ratio_consoIO1IN <- conso_IO1/consoVNtemp # N'a de sens (bien-entendu) qu'a partir de 1996
ratio_conso <- conso_IO1/consoVNtemp # N'a de sens (bien-entendu) qu'a partir de 1996
print(ration_conso)
print(ratio_conso)
ratio_conso <- conso_IO1/conso_VN[1:237] # N'a de sens (bien-entendu) qu'a partir de 1996
ratio_conso_IN_moy = ratio_conso[35:233]*IN_moy[22:220]
res5= lm(IO1t_cjo[35:233]~
ratio_conso_IN_moy + Ratio_IPC_IN_moy + IN_moy[22:220] - 1)
summary(res5)
